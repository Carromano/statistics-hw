<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Simulazione Penetrazione Server con Chart.js</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
            background-color: #c7c7c7;
        }
        h1 {
            color: #333;
        }
        #controls {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        #controls label {
            margin-right: 5px;
        }
        #chartsContainer {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 20px;
            margin: 50px;
        }
        canvas {
            background-color: #fff;
        }
        button {
            padding: 5px 15px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #444444;
        }

        .error-message {
            color: red;
            font-weight: bold;
            margin-top: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <h2> Risultato: </h2>

    <div id="controls">
        <label># of Servers (n): <input type="number" id="n" value="10" min="1"></label><br>
        <label># of Hackers (m): <input type="number" id="m" value="5" min="1"></label><br>
        <label>Probability (p): <input type="number" id="p" value="0.5" step="0.01" min="0" max="1"></label><br>
        <label>Time (t): <input type="number" id="t" value="5" step="1" min="1"></label><br>
        <button id="simulateButton" onclick="runSimulation()">Esegui Simulazione</button><br>
        <p id="errorMessage" class="error-message">Errore: Il tempo (t) deve essere minore o uguale al numero di server (n).</p>
    </div>

    <div id="chartsContainer">
        <canvas id="penetrationChart" width="800" height="400"></canvas>
        <canvas id="midHistogramChart" width="400" height="400"></canvas>
        <canvas id="histogramChart" width="400" height="400"></canvas>
    </div>

    

    <script>
        const nInput = document.getElementById('n');
        const tInput = document.getElementById('t');
        const simulationButton = document.getElementById('simulateButton');
        const errorMessage = document.getElementById('errorMessage');

        // instances of both graphs we will use later
        let penetrationChart = null;
        let midHistogramChart = null;
        let histogramChart = null;

        // array with the list of colors used to draw hackers in the graph
        let colors = [
            'rgba(0, 0, 235, 1)',       // Blue
            'rgba(255, 220, 30, 1)',    // Yellow
            'rgba(115, 255, 212, 1)',   // aquamarine
            'rgba(203, 102, 255, 1)',   // purple
            'rgba(255, 159, 64, 1)',    // orange
            'rgba(100, 100, 100, 1)',   // gray
            'rgba(81, 209, 246, 1)',    // soft blue
        ];

        let freqColors = [
            'rgba(255, 0, 0, 1)',       // Red
            'rgba(60, 255, 50, 1)',     // Green    
        ];

        // function that generates a random color in the rgb format
        function getRandomColor() {
            const r = Math.floor(Math.random() * 256);  // generates a random value from 0 to 255 for red
            const g = Math.floor(Math.random() * 256);  // generates a random value from 0 to 255 for green
            const b = Math.floor(Math.random() * 256);  // generates a random value from 0 to 255 for blue

            return `rgb(${r}, ${g}, ${b}, 1)`;          // outputs the result in RGB format
        }

        // Function validating the values of n and t at input time.
        function validateInputs() {
            let nValue = parseInt(nInput.value);
            let tValue = parseInt(tInput.value);

            // if the value of t is greater of the number of servers, we disable the button to run the simulation and show an error message.
            // This is in order to avoid errors in the graphs.
            if (tValue > nValue) {
                errorMessage.style.display = 'block';
                simulationButton.disabled = true;
            } else {
                errorMessage.style.display = 'none';
                simulationButton.disabled = false;
            }
        }

        // adding listeners to the inputs to avoid errors.
        nInput.addEventListener('input', validateInputs);
        tInput.addEventListener('input', validateInputs);



        // function that simulates the attacks and saves the results
        function runSimulation() {
            if (midHistogramChart){
                histogramChart = null;
            }

            if (histogramChart){
                histogramChart = null;
            }

            // Takes data from the input fields
            const n = parseInt(document.getElementById('n').value);
            const m = parseInt(document.getElementById('m').value);
            const t = parseInt(document.getElementById('t').value);
            const p = parseFloat(document.getElementById('p').value);
            

            // Fill the colors array if there are less than m colors
            while(colors.length < m) {
                newColor = getRandomColor();
                while(colors.includes(newColor) || freqColors.includes(newColor)){
                    newColor = getRandomColor();
                }
                colors.push(newColor);
            }

            // definition of useful matrix
            let penetrationHistory = Array.from({ length: m }, () => Array(n).fill(0));
            let serverStates = Array.from({ length: m }, () => Array(n).fill(0));

            
            // simulation of the attacks
            for (let h = 0; h < m; h++) {
                let cumulative = 0;
                for (let s = 0; s < n; s++) {

                    //-1/+1 jumps with probability p (A)
                    if (Math.random() < p) {
                        serverStates[h][s] = 1;
                        cumulative++;
                    } else {
                        serverStates[h][s] = -1;
                        cumulative--;
                    }

                    penetrationHistory[h][s] = cumulative;
                }
            }

            //definition of the variables we will use to represent Relative and Absolute frequence Trajectories (B)
            const { absolute, relative } = calculateFreq(penetrationHistory);

            //draws the graphs
            const midHistogramData =calculateHistogram(t);
            const histogramData = calculateHistogram(serverStates, n);
            drawPenetrationChart(penetrationHistory, absolute, relative, n, m);

            drawHistogramChart(histogramData, midHistogramData, n);
        }


        // Funzione per calcolare le frequenze assolute e relative
        function calculateFreq(penetrationHistory) {
            let abs = Array(penetrationHistory[0].length).fill(0);
            let rel = Array(penetrationHistory[0].length).fill(0);

            // Calcolo delle frequenze assolute e relative per ogni server
            penetrationHistory.forEach((history, h) => {
                history.forEach((val, s) => {
                    abs[s] += val;
                });
            });

            // Calcolo delle frequenze relative (in percentuale)
            for (let i = 0; i < abs.length; i++) {
                rel[i] = abs[i] / penetrationHistory.length;
            }

            return { absolute: abs, relative: rel };
        }
/*
        // function that calculates the total results for the Histogram
        // function calculateHistogram(serverStates, n) {

        //     // Counts the total 
        //     let counts = Array(n + 1).fill(0);
        //     for (let h = 0; h < serverStates.length; h++) {
        //         const total = serverStates[h].reduce((acc, val) => acc + val, 0);
        //         counts[total]++;
        //     }
        //     return counts;

        // }

*/

        function calculateHistogram(serverStates, t){
            let counts = Array(n + 1).fill(0);
            
            for (let h = 0; h < serverStates.length; h++) {
                const total = serverStates[h].slice(0, t).reduce((acc, val) => acc + val>0?val:0, 0);
                counts[total]++;
            }
        }

        // function that draws the penetration graph
        function drawPenetrationChart(data, abs, rel, n, m) {
            // creation of labels
            const labels = Array.from({ length: n }, (_, i) => `Server ${i + 1}`);

            // Creazion of the Dataset
            const datasets = data.map((history, h) => ({
                label: `Hacker ${h + 1}`,
                data: history,
                borderColor: colors[h % colors.length],
                fill: false,
                tension: 0.1,
                order: 5
            }));

            const absFreq = {
                label: 'Absolute Frequence',
                data: abs,
                borderColor: freqColors[0],
                fill: false,
                borderWidth: 6,  
                tension: 0.3,
                order:2
            };

            const relFreq = {
                label: 'Relative Frequence',
                data: rel,
                borderColor: freqColors[1],
                fill: false,
                borderWidth: 6,  
                tension: 0.3,
                order:3
            };

            const allDatasets = [...datasets, absFreq, relFreq];


            // Reset the old graph
            if (penetrationChart) {
                penetrationChart.destroy();
            }

            // take the HTML element
            const ctx = document.getElementById('penetrationChart').getContext('2d');

            // Creation of the new graph
            penetrationChart = new Chart(ctx, {
                type: 'line',
                // dataset
                data: {
                    labels: labels,
                    datasets: allDatasets
                },
                // label and axes options
                options: {
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Numero di Server'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Numero di Successi'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }



        // function that draws the histogram
        function drawHistogramChart(data, midData, n) {

            // Creation of labels and dataset
            const labels = Array.from({ length: n + 1 }, (_, i) => i);

            if (midHistogramChart){
                const dataset = {
                    label: 'Numero di Hacker',
                    data: data,
                    backgroundColor: 'rgba(75, 192, 192, 0.7)'
                };

                // Reset the old graph
                if (histogramChart) {
                    histogramChart.destroy();
                }

                // takes the HTML element
                const ctx = document.getElementById('histogramChart').getContext('2d');

                // creates the new graph
                histogramChart = new Chart(ctx, {
                    type: 'bar',
                    // dataset
                    data: {
                        labels: labels,
                        datasets: [dataset]
                    },
                    // axes options
                    options: {
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Numero di Server Penetrati'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Numero di Hacker'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });

            } else {

                const dataset = {
                    label: 'Numero di Hacker',
                    data: midData,
                    backgroundColor: 'rgba(75, 192, 192, 0.7)'
                };

                // Reset the old graph
                if (midHistogramChart) {
                    midHistogramChart.destroy();
                }

                // takes the HTML element
                const ctx = document.getElementById('midHistogramChart').getContext('2d');

                // creates the new graph
                midHistogramChart = new Chart(ctx, {
                    type: 'bar',
                    // dataset
                    data: {
                        labels: labels,
                        datasets: [dataset]
                    },
                    // axes options
                    options: {
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Numero di Server Penetrati a tempo t'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Numero di Hacker'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
        }

        // command to run the simulation opening the window
        window.onload = runSimulation;
    </script>
</body>
</html>



